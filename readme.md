# SkibidiLang

Welcome to SkibidiLang, the sigma-level language that mogs the competition with its goated, meme-infused syntax. Built using LLVM because we’re not playing in Ohio, this language’s rizz is unmatched.

Features

    ✅ Internet-slang syntax that'll have your code looking bussin' fr fr.
    ✅ LLVM-backed compilation so your skibidi shenanigans run with giga-chad performance.
    Supports:
    ✅ Variables (pookie declarations? Say less.)
    ✅ Control flow (if/else? No cap.)
    ✅ Loops (bet and goon for days)
    ✅ Functions (all the bruhs)
    ⬜️ Arrays (squad goals)
    ⬜️ Classes (sigma vibes only)
    ⬜️ Error handling (delulu-proof)

Syntax Highlights

# Brain Rott Programming Language

## Syntax Highlights

### Mew-Level Keywords
- **yap**: Print that bad boy to the console.
- **fr, no_cap, cap**: If/else logic that’s sigma-certified.
- **bet**: For when you gotta loop like Baby Gronk training to rizz up Livee Dunn.
- **goon**: Infinite loop for the real giga-chads.
- **bruh**: Function declaration because saying “function” is beta.
- **pookie**: Variable declaration (cute but deadly).
- **sigma**: Class declaration for that Level 100 boss rizz.
- **squad**: Array, because teams mog solos.
- **yeet, yoink**: Squad ops for all your Grimace shake-coded needs.
- **cook**: Main function to chef up your code.
- **ghost**: Exit the program when you’re done mogging.

### Control Flow Keywords
- **edgy**: If statement to check conditions.
- **amogus**: Else statement for alternative paths.
- **goon (condition)**: While loop for repeated execution.
- **mewing (block)**: Do-while loop structure.

### Special Functionality
- **goated bruh**: High-priority function declaration.

### Snippet of Pure Skibidi Energy

### Built-in Functions
- **yapping**: Print text with a newline.
- **yappin**: Print text without a newline.
- **baka**: Print to standard error for error handling.
- **ragequit**: Terminate program execution immediately with an exit code.

### Operators
The language supports basic arithmetic and logical operators:
- `+`: Addition
- `-`: Subtraction
- `*`: Multiplication
- `/`: Division
- `=`: Assignment
- `<`: Less than
- `>`: Greater than
- `&&`: Logical AND
- `||`: Logical OR


Snippet of Pure Skibidi Energy:

cook {
    pookie x = 42;
    yap("no cap fr fr:", x);

    no_cap (x > 40) {
        yap("bussin!");
    } cap {
        yap("not bussin :(");
    }
}
ghost;

Building from Source

Pre-Rizzquisites

	•	CMake 3.20+ (no Ohio versions)
	•	LLVM (brew install for the real homies)
	•	C++17 compatible compiler (we don’t do cringe stuff)

Get Your Build On:

	1.	Clone this skibidi sigma-level repo:

git clone https://github.com/iabdullahW/brainrot-prog-lang-1.git
cd brainrot-prog-lang-1

	2.	Create that build den:

mkdir build && cd build

	3.	Cook up the project:

cmake ..
make

Project Vibes

	•	Lexer – Defines the vibes and tokens (think: yap, goon, sigma – the whole pookie package).
	•	Parser – Ensures your syntax ain’t ohio cringe.
	•	Code Generator – Turns your giga-rizzed code into LLVM flex-worthy binaries.

Running Your Code

Slap your .skibidi program into existence:

First, [install llvm](https://llvm.org/docs/GettingStarted.html).

build the brainrot lang:

```
cd build 
rm -rf *
cmake ..
make
```

./skibidilang your_program.skibidi

Full Mogging Sample:

sigma SquadManager {
    pookie squad = []; 

    bruh addMember(pookie member) {
        delulu {
            yoink squad[squad.length] = member;
            yap("Member yoinked: ", member);
            solulu squad;
        } catch (error) {
            oof("Error while yoinking member: ", error);
        }
    }

    bruh removeMember(pookie index) {
        sus (index < squad.length && index >= 0) {
            yeet squad[index];
            yap("Member yeeted from position: ", index);
            solulu squad;
        } bussin (squad.length == cap) {
            oof("Can't yeet from an empty squad.");
        } no_cap {
            oof("Invalid index for yeet operation.");
        }
    }

    bruh showSquadDetails() {
        sus (squad.length == cap) {
            yap("The squad is empty, pookie.");
        } no_cap {
            yap("Current squad: ", squad);
        }
        solulu ohio;
    }

    goated bruh findMember(pookie name) {
        pookie found = ohio;
        bet (pookie i = 0; i < squad.length; i++) {
            sus (squad[i] == name) {
                found = name;
                break;
            }
        }
        sus (found != ohio) {
            yap("Pookie found: ", found);
        } no_cap {
            yap("Pookie not found.");
        }
        solulu found;
    }
}

Contributions

Slide into the Pull Requests like you’re dropping a Grimace shake on a hot summer day. All giga-chad contributions welcome.

Limitations (for now, at least)

	•	Basic data types only (no custom Ohio-types yet).
	•	Some parts are still Beta-coded, not Sigma.
	•	Platform-specific tweaks because we can’t all be mogging everywhere at once.

Future Gyatt Plans

	•	Array implementation (squad functionality ain't bussin' yet)
	•	Class support (sigma grindset needs that OOP rizz)
	•	Error handling with delulu/solulu (catch those Ohio moments)
	•	Bigger, better standard library (more built-in skibidi features)
	•	Package management (for when squads get complex)
	•	IDE plugin (one-tap Livee Dunn-worthy mogs)
	•	Maxed out optimization rizz (LLVM passes and optimizations)
	•	Memory management (no more memory leaks fr fr)
	•	Type system (static typing to keep it bussin')
	•	Debugging tools (find those no cap moments)

Shoutouts

	•	LLVM IR for the core juice
	•	Meme-coding kings and queens
	•	All pookies helping make this Level 100.
